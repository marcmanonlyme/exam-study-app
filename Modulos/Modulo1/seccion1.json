[
  {
    "question": "¿Qué es un tipo de dato primitivo en programación?",
    "options": ["Una clase definida por el usuario", "Una estructura de control", "Un tipo básico proporcionado por el lenguaje", "Una función matemática"],
    "answer": 2,
    "explanation": "Los tipos de datos primitivos son los más básicos, como entero, booleano o carácter, y son proporcionados por el lenguaje."
  },
  {
    "question": "¿Cuál es la estructura de datos más adecuada para representar una jerarquía?",
    "options": ["Lista", "Cola", "Árbol", "Pila"],
    "answer": 2,
    "explanation": "Los árboles permiten representar relaciones jerárquicas como padre-hijo, ideales para estructuras como directorios o genealogías."
  },
  {
    "question": "¿Qué algoritmo tiene una complejidad promedio de O(n log n)?",
    "options": ["Burbuja", "Quicksort", "Selección", "Inserción"],
    "answer": 1,
    "explanation": "Quicksort es eficiente en promedio, con complejidad O(n log n), aunque en el peor caso puede ser O(n²)."
  },
  {
    "question": "¿Qué principio SOLID indica que una clase debe tener una sola razón para cambiar?",
    "options": ["Open/Closed", "Liskov Substitution", "Single Responsibility", "Interface Segregation"],
    "answer": 2,
    "explanation": "El principio de responsabilidad única (SRP) establece que una clase debe tener una sola responsabilidad."
  },
  {
    "question": "¿Qué modelo de desarrollo enfatiza la gestión de riesgos en cada iteración?",
    "options": ["Cascada", "Incremental", "Ágil", "Espiral"],
    "answer": 3,
    "explanation": "El modelo espiral incorpora análisis de riesgos en cada ciclo, ideal para proyectos complejos y cambiantes."
  },
  {
    "question": "¿Qué tipo de prueba verifica que el sistema cumple con los requisitos del usuario?",
    "options": ["Prueba unitaria", "Prueba de integración", "Prueba de validación", "Prueba de regresión"],
    "answer": 2,
    "explanation": "La validación asegura que el sistema cumple con lo que el usuario espera, según los requisitos definidos."
  },
  {
    "question": "¿Qué estructura de datos sigue el principio FIFO?",
    "options": ["Pila", "Cola", "Árbol", "Lista circular"],
    "answer": 1,
    "explanation": "La cola (queue) sigue el principio FIFO: primero en entrar, primero en salir."
  },
  {
    "question": "¿Qué técnica divide un problema en subproblemas más pequeños del mismo tipo?",
    "options": ["Iteración", "Recursión", "Encapsulamiento", "Herencia"],
    "answer": 1,
    "explanation": "La recursión permite resolver problemas dividiéndolos en versiones más simples de sí mismos."
  },
  {
    "question": "¿Qué tipo de prueba se realiza después de corregir un error para asegurar que no se introdujeron nuevos fallos?",
    "options": ["Prueba de aceptación", "Prueba de regresión", "Prueba de integración", "Prueba de carga"],
    "answer": 1,
    "explanation": "La prueba de regresión verifica que los cambios no hayan afectado funcionalidades existentes."
  },
  {
    "question": "¿Qué norma define procesos del ciclo de vida del software?",
    "options": ["ISO/IEC 9126", "IEEE 830", "ISO/IEC 12207", "IEEE 1012"],
    "answer": 2,
    "explanation": "La norma ISO/IEC 12207 establece los procesos del ciclo de vida del software desde su concepción hasta su retiro."
  },
  {
    "question": "¿Qué estructura de datos permite insertar y eliminar elementos en ambos extremos?",
    "options": ["Pila", "Cola", "Lista doblemente enlazada", "Árbol binario"],
    "answer": 2,
    "explanation": "Una lista doblemente enlazada permite operaciones en ambos extremos, a diferencia de pilas y colas que son unidireccionales."
  },
  {
    "question": "¿Cuál es la principal ventaja de usar una lista enlazada sobre un array?",
    "options": ["Acceso aleatorio más rápido", "Menor uso de memoria", "Inserción y eliminación eficientes", "Mayor seguridad"],
    "answer": 2,
    "explanation": "Las listas enlazadas permiten insertar y eliminar elementos sin necesidad de mover otros elementos o redimensionar."
  },
  {
    "question": "¿Qué tipo de prueba se realiza para verificar que los componentes individuales funcionan correctamente?",
    "options": ["Prueba de sistema", "Prueba de integración", "Prueba unitaria", "Prueba de aceptación"],
    "answer": 2,
    "explanation": "La prueba unitaria se enfoca en validar el comportamiento de componentes individuales como funciones o clases."
  },
  {
    "question": "¿Qué principio SOLID establece que los módulos deben estar abiertos para extensión pero cerrados para modificación?",
    "options": ["Single Responsibility", "Open/Closed", "Liskov Substitution", "Dependency Inversion"],
    "answer": 1,
    "explanation": "El principio Open/Closed promueve que el código pueda extenderse sin modificar su estructura original."
  },
  {
    "question": "¿Qué modelo de desarrollo sigue una secuencia rígida de fases sin retroalimentación?",
    "options": ["Ágil", "Incremental", "Cascada", "Espiral"],
    "answer": 2,
    "explanation": "El modelo en cascada avanza fase por fase sin retroalimentación ni iteraciones."
  },
  {
    "question": "¿Qué técnica permite detectar errores al comparar versiones anteriores y actuales del software?",
    "options": ["Prueba de integración", "Prueba de regresión", "Prueba de sistema", "Prueba de aceptación"],
    "answer": 1,
    "explanation": "La prueba de regresión verifica que los cambios no hayan introducido errores en funcionalidades existentes."
  },
  {
    "question": "¿Qué estructura de datos es más adecuada para implementar una agenda de tareas con prioridad?",
    "options": ["Cola simple", "Pila", "Cola de prioridad", "Lista enlazada"],
    "answer": 2,
    "explanation": "Una cola de prioridad organiza elementos según su importancia, ideal para tareas urgentes."
  },
  {
    "question": "¿Qué tipo de prueba se realiza después de corregir un error para asegurar que no se introdujeron nuevos fallos?",
    "options": ["Prueba de aceptación", "Prueba de regresión", "Prueba de integración", "Prueba de carga"],
    "answer": 1,
    "explanation": "La prueba de regresión asegura que los cambios no afectaron funcionalidades previas."
  },
  {
    "question": "¿Qué principio SOLID promueve que las dependencias se basen en abstracciones y no en clases concretas?",
    "options": ["Interface Segregation", "Dependency Inversion", "Liskov Substitution", "Single Responsibility"],
    "answer": 1,
    "explanation": "La inversión de dependencias indica que los módulos deben depender de abstracciones, no de implementaciones concretas."
  },
  {
    "question": "¿Qué estructura de datos permite representar múltiples caminos entre nodos?",
    "options": ["Árbol", "Grafo", "Pila", "Cola"],
    "answer": 1,
    "explanation": "Los grafos permiten múltiples conexiones entre nodos, ideales para redes sociales o mapas."
  }
]
